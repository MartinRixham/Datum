{
  "name": "Datum",
  "tagline": "An opinionated data binding library.",
  "body": "# Datum.js\r\n\r\nAn opinionated data binding library.\r\n\r\n## The Basics Of Data Binding With Datum\r\n\r\n### Initialisation\r\n\r\nThe two components of a web page built with Datum.js are the *template* and the *view model*.\r\nThe template is the HTML between the `<body> </body>` tags before Datum.js has modified it.\r\nYou the developer are responsible for putting the tempate in the body of the DOM.\r\nDatum.js is agnostic about how you do this.\r\n(If you're having trouble jQuery's [load](https://api.jquery.com/load/) method is a good option.)\r\n\r\nThe view model is a single JavaScript object that contains all of the data that will be displayed on the web page and all of the logic for interacting with the web page.\r\nYou tell Datum.js what object this is by passing it to a constructor called `BindingRoot`.\r\n\r\n    var viewModel = {};\r\n    \r\n    new BindingRoot(viewModel);\r\n    \r\nDeclaring the binding root can be done only once, presumably as soon as the page loads.\r\n\r\n### The View Model\r\n\r\nThe view model has two kinds of property, *data properties* and *bindings*.\r\nThe data properties contain the data that define the state of the view model.\r\nThe bindings are special objects that define how that data is displayed on the page.\r\nYou can create a binding using the `Binding` constructor.\r\n\r\n    var viewModel = {\r\n    \r\n        myDatum: \"Hello world.\",\r\n        myBinding: new Binding();\r\n    };\r\n    \r\n    new BindingRoot(viewModel);\r\n    \r\n### Binding Attributes\r\n\r\nEach binding property has at least one corresponding *binding attribute* on the template.\r\nThis attribute tells Datum.js which DOM element to bind each binding to.\r\nA Binding attribute is always called `data-bind` and its value is the name of the binding property in the view model.\r\n\r\n    <body>\r\n      <div data-bind=\"myBinding\"></div>\r\n    </body>\r\n\r\n### Callbacks\r\n\r\nThe binding `myBinding` above will have no effect on the page.\r\nTo make something happen you need to construct the binding with a callback.\r\nThere are a few different callbacks you can use.\r\nThe one called `text` is used to put text on the page.\r\n\r\n    var viewModel = {\r\n    \r\n        myDatum: \"Hello world.\",\r\n        myBinding: new Binding({\r\n        \r\n            text: function() { return this.myDatum; }\r\n        });\r\n    };\r\n    \r\n    new BindingRoot(viewModel);\r\n    \r\n### Text\r\n\r\nAs seen above, the *text callback* sets the text content of the elements to which it is bound.\r\nThe callback can contain any logic so long as it returns the value which is to be displayed.\r\nIf any of the data properties used in the body of the callback changes, the text callback will be reevaluated and the text on the page updated.\r\nIn the example above you can change the text on the page by assigning to the `myDatum` proprety.\r\n\r\n    viewModel.myDatum = \"Eh up planet.\";\r\n    \r\nThe text callback has a parameter which is the element to which it is bound.\r\nYou can also create a text binding using the `Text` constructor, but generally it is more useful to use the `Binding` constructor so you can also pass it some of the callbacks described below.\r\n\r\n    var viewModel = {\r\n    \r\n        myDatum: \"Hello world.\",\r\n        myBinding: new Text(function(element) { return this.myDatum; });\r\n    };\r\n    \r\n    new BindingRoot(viewModel);\r\n    \r\n### Value\r\n\r\nThe *value callback* provides a two way binding between an `<input />` element and a data property.\r\nIt is a single callback that is called when either a change event is triggered on the input element or one of the data dependencies of the callback changes.\r\nIn the first case the value of the input element is passed as the first parameter to the callback.\r\nIn the second case `undefined` is passed.\r\nThe second parameter is always the element to which it is bound.\r\n\r\n```\r\n    <body>\r\n      <input type=\"text\" data-bind=\"myBinding\" />\r\n    </body>\r\n```\r\n```\r\n    var viewModel = {\r\n    \r\n        myDatum: \"Hello world.\",\r\n        myBinding: new Binding({\r\n        \r\n            value: function(value) { \r\n            \r\n                if (value) {\r\n                \r\n                    this.myDatum = value;\r\n                }\r\n                \r\n                return this.myDatum; \r\n            }\r\n        });\r\n    };\r\n    \r\n    new BindingRoot(viewModel);\r\n```\r\nA standard two way binding will have the above form, though of course you are free to experiment.\r\nThere is also a `Value` constructor to which you can pass the callback directly.\r\n\r\n### Click\r\n\r\nThe *click callback* is called whenever a click event is raised on an element to which it is bound.\r\nAgain the element is passed as the first paramenter and there is also a `Click` constructor.\r\n\r\n```\r\n    <body>\r\n      <button id=\"button-id\" data-bind=\"myBinding\"></button>\r\n    </body>\r\n```\r\n```\r\n    var viewModel = {\r\n    \r\n        myDatum: \"The text on the button\",\r\n        myBinding: new Binding({\r\n        \r\n            text: function() { return this.myDatum; },\r\n            click: function(element) { \r\n            \r\n                alert(\"You just clicked the button with id \" + element.id + \".\");\r\n            }\r\n        });\r\n    };\r\n    \r\n    new BindingRoot(viewModel);\r\n```\r\n### Init\r\n\r\nThe *init callback* is called when the binding is bound to an element.\r\nAfterwards the init callback will not be called again for that element, but will be called if the binding is bound to a new element, each time passing the bound element as the first parameter.\r\nIf you want to manually attach event handlers to an element then this is a good place to do it.\r\n\r\n### Update\r\n\r\nThe *update callback* does not react directly to any DOM event.\r\nIt is called when the binding is first attached to an element and then again whenever one of its dependencies changes.\r\n\r\nAn import thing to understand is that unlike other bindings such as text and value, the dependencies of the update callback are registered only when it is first bound.\r\nFor further details see the section on dependency collection.\r\n\r\n### Visible\r\n\r\nThe *visible callback* can be used to hide and show elements.\r\nIf the callback returns false the element will have the style `display: none;` applied to it.\r\nIf the callback returns true the display style will be set to the value it had when the element was first bound.\r\n\r\n### The Object Binding\r\n\r\nThe view model will typically be a nested data structure with sub-objects bound to parts of the DOM.\r\nA sub-object bound to an element becomes the view model for the part of the DOM made up of that element and its sub-elements.\r\nJust like its parent view model it can have data properties, binding properties and its own sub-objects.\r\nObjects are bound to elements in the same way as bindings by putting a `data-bind` attribute on the element whose value is the name of object property.\r\n\r\n```\r\n    <body>\r\n      <div data-bind=\"mySubobject\">\r\n        <span data-bind=\"text\"></span>\r\n      </div>\r\n    </body>\r\n```\r\n```\r\n    var viewModel = {\r\n    \r\n        mySubobject: {\r\n\r\n            text: new Text(function() { return \"Hello world.\"; })\r\n        }\r\n    };\r\n    \r\n    new BindingRoot(viewModel);\r\n```\r\nBe careful to ensure that the structure of the view model is mirrored in the DOM hierarchy.\r\nAn object bound to an element must contain all bindings within that element.\r\nNo binding can be applied from outside the bound object even if the property name is that same as the binding attribute.\r\n\r\nThe object binding has one more useful feature.\r\nIf the a bound object is set to null then the element to which it is bound will be removed from the DOM.\r\nIf the object is replaced then the element is put back too.\r\nThus parts of the DOM can be shown only when there is data available to populate them.\r\nThis is a more natural way to hide and show elements than the visible binding.\r\n\r\n### The Array Binding\r\n\r\nThe array binding is quite like the object binding except the contents of the element to which an array is bound will be repeated for each element of the bound array.\r\n\r\n## Advanced Topics\r\n\r\n### DOM Mutation\r\n\r\nA unique feature of Datum is its ability to cope with updates to both the view model and the DOM.\r\nAs expected the DOM will be automatically updated to reflect changes in the view model.\r\nBut if you manually update the DOM say by attaching a new template, the view model will simply bind to the new template poplating it with the same data, but potentially with a new layout.\r\n\r\nThe best practice when using Datum is to take full advantage of this capability by incremetally biding templates to the view model only when they are need on the page.\r\nSo although Datum only allows one view model and one template on a page it is perfectly possible to asynchronously load components onto the page at any point during the running of the application.\r\n\r\n### The Binding Callback\r\n\r\nOften the most convenient time to load a new template is just after binding its view model to the DOM using the object binding.\r\nThis way the template can be placed straight inside the element to which the view model was just bound.\r\nTo facilitate this when applying the object binding Datum will look for and call a method called `onBind` if it exists on the object being bound.\r\nThe element to which the object was just bound is passed as the first parameter to `onBind` so a new template can be easily placed inside the element.\r\n\r\n    var viewModel = {\r\n\r\n        onBind: function(element) {\r\n\r\n\t\t\t$(element).load(\"myTemplate.html\");\r\n\t\t},\r\n    };\r\n\r\n\tnew BindingRoot(viewModel);\r\n\r\n### Dependency tracking\r\n\r\nAll of the binding callbacks that can be passed to the `Binding` constructor track their own dependencies.\r\nThis means that you don't have to worry about updating any of the data on the page when the data in the view model changes.\r\nThis will happen automatically.\r\n\r\nDo be aware though, that dependencies are tracked by calling the binding callback and detecting which properties are called during its execution.\r\nThis can happen many times so you have little control over when and how often a binding callback is called.\r\n\r\n### Dependency Collection\r\n\r\nEven if the implementation of a binding callback doesn't change, the dependencies of that callback can change during runtime.\r\nFor example some dependencies may be called inside an `if` statement so won't be detected if that `if` initially returns false.\r\nThis means that there is a trade-off when collecting dependencies.\r\nEither execute the callback frequently to see if it has any new dependencies or execute it less often, perhaps only once and run the risk of a dependency being missed.\r\nIn almost every case Datum takes the first option aggresively collecting dependencies so that none are ever missed.\r\nThis means that you should never put expensive computation or expensively access resouces from a binding callback or call any method that would do so.\r\nIn particuar you should never initiate network requests from a binding callback.\r\n\r\nOf course you may well want to make a network request or access an expensive resource automatically when the view model updates.\r\nIn this case the correct tool is the *update* binding.\r\nIn contrast to all the other binding callbacks, the update binding collects its dependencies only once when it is first bound.\r\nAfter that it is only re-executed when one of those dependencies changes.\r\nIt is therefore safe to put expensive operations in an update binding since they will only be run when necessary.\r\nHowever you must make sure that all of it's dependencies can be found when they are initally collected.\r\n\r\n### Serialisation\r\n\r\nIt is common to want to be able to turn objects into JSON to send to the server.\r\nFor this reason Datum attaches a `toJSON` method to each object in the view model.\r\nThis method returns an object containing only data properties and subobjects that can be easily stringified and sent to the server.\r\n\r\n    var viewModel = {\r\n    \r\n        datum: \"Hello world.\"\r\n    };\r\n    \r\n    new BindingRoot(viewModel);\r\n\r\n\tvar jsonString = JSON.stringify(viewModel);\r\n\r\nIf an object contains data that should not be serialised then it can implement its own `toJSON` method.\r\nThis method should return an object that contains just its serialisable data.\r\nBeginners are encouraged to use the default implementation of `toJSON` and not to worry if a few redundant properties are sent to the server.\r\n\r\n### The Array Binding\r\n\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}